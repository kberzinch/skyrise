#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in7,    PylonPot,       sensorPotentiometer)
#pragma config(Sensor, in8,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  SolenoidCubes,  sensorDigitalOut)
#pragma config(Sensor, dgtl2,  SolenoidPylons, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  LiftLimitMinA,  sensorTouch)
#pragma config(Sensor, dgtl4,  LiftLimitMinB,  sensorTouch)
#pragma config(Sensor, dgtl5,  MainBattLEDGreen, sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  MainBattLEDRed, sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  BackupBattLEDGreen, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  BackupBattLEDRed, sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           DriveCenter,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           LiftLeftTop,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LiftRightTop,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           DriveFrontLeft, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           DriveFrontRight, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port6,           DriveRearLeft, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           DriveRearRight, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port8,           LiftLeftBottom, tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           LiftRightBottom, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port10,          PylonMotor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const string FILE = __FILE__;
int Pylon_Target = 1800;
task PylonLock;

#define NoPowerExpander
const tMotor LiftLeftA = LiftLeftTop;
const tMotor LiftLeftB = LiftLeftBottom;
const tMotor LiftRightA = LiftRightTop;
const tMotor LiftRightB = LiftRightBottom;
const tSensors LiftEncoder = I2C_4;
const tSensors DriveEncoder = I2C_2;
#include "core\v3\batteryindicators.h"
#include "core\v3\core.h"
#include "misc\2105A-stabilizers.h"
#include "auton\2105A-red-atloader.h"
#include "misc\2105A-autonmanager.h"
#include "usercontrol\2105A-john.h"

void init() {
	nMotorEncoder[LiftLeftBottom] = 0;
	nMotorEncoder[LiftRightBottom] = 0;
	SensorValue[SolenoidPylons] = 0;
	SensorValue[SolenoidCubes] = 0;
}

void ResetDriveEncoders() {
	nMotorEncoder[DriveCenter] = 0;
	nMotorEncoder[DriveFrontRight] = 0;
}

task PylonLock {
	const float PKp = 1;
	const float PKd = 1.5;
	const float PKi = 0.001;
	const tSensors PsensorRight = PylonPot;
	const int PrightAdjust = 0; // -350;
	const int PrightMultiplier = 1;
	const int PIntegralLimit = 200;
	const int PMax = 3200;
	const int PMin = 700;
	bool PMinOverride = false;
	const tSensors sensor = PsensorRight;
	const tMotor motor1 = PylonMotor;
	const int offset = PrightAdjust;
	const int mult = PrightMultiplier;
	int error = 0, previous_error = 0, speed = 0, derivative = 0, integral = 0;
	int last_nSysTime = nSysTime;
	while(true) {
		if(((mult * SensorValue[sensor]) + offset) > PMax || (((mult * SensorValue[sensor]) + offset) < PMin && !PMinOverride)) {
			motor[motor1] = 0;
			error = 0;
			integral = 0;
			derivative = 0;
			previous_error = 0;
			continue;
		}
		error = (Pylon_Target - ((mult * SensorValue[sensor]) + offset));
		if(abs(error) < PIntegralLimit) {
			integral += error / divisible(nSysTime - last_nSysTime);
			} else {
			integral = 0;
		}
		derivative = (error - previous_error) / divisible(nSysTime - last_nSysTime);
		last_nSysTime = nSysTime;
		previous_error = error;
		speed = PKp * error + PKd * derivative + PKi * integral;
		motor[motor1] = Normalize(speed);
	}
}
