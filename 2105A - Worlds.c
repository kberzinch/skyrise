#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  CollectionCube, sensorDigitalOut)
#pragma config(Sensor, dgtl2,  SolenoidPylon,  sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           DriveMiddle,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           DriveRearLeft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DriveFrontRight, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           DriveRearRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           DriveFrontLeft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LiftTopLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LiftBottomLeft, tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port8,           LiftTopRight,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           PylonServo,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          LiftBottomRight, tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "misc\2105A-stabilizers.h"

task main {
	nMotorEncoder[LiftBottomLeft] = 0;
	nMotorEncoder[LiftBottomRight] = 0;
	clearDebugStream();
	Set_Lift_Target();
	while(true) {
		motor[DriveFrontLeft]  = -(vexRT[Ch2] + vexRT[Ch4]);
		motor[DriveFrontRight] =  (vexRT[Ch2] - vexRT[Ch4]);
		motor[DriveRearLeft]   = -(vexRT[Ch2] + vexRT[Ch4]);
		motor[DriveRearRight]  =  (vexRT[Ch2] - vexRT[Ch4]);
		motor[DriveMiddle]     =   vexRT[Ch1];
		if(vexRT[Btn6U] == 1) {
			Set_Lift_Target();
			IsStabilizerRunning = false;
			motor[LiftTopLeft]     =  127;
			motor[LiftBottomLeft]  =  127;
			motor[LiftTopRight]    =  127;
			motor[LiftBottomRight] =  127;
			} else if(vexRT[Btn6D] == 1) {
			IsStabilizerRunning = false;
			Set_Lift_Target();
			motor[LiftTopLeft]     = -127;
			motor[LiftBottomLeft]  = -127;
			motor[LiftTopRight]    = -127;
			motor[LiftBottomRight] = -127;
			} else {
			if(!IsStabilizerRunning) {
				Set_Lift_Target();
				/*motor[LiftTopLeft]     = 0;
				motor[LiftBottomLeft]  = 0;
				motor[LiftTopRight]    = 0;
				motor[LiftBottomRight] = 0;*/
				startTask(Lift_Stabilizer_Left);
				startTask(Lift_Stabilizer_Right);
			}
		}
		SensorValue[CollectionCube] = vexRT[Btn5D];
		SensorValue[SolenoidPylon] = vexRT[Btn5U];
		if(vexRT[Btn7U] == 1) {
			motor[PylonServo] = 0;
		} else if(vexRT[Btn7L] == 1) {
			motor[PylonServo] = -127;
		} else if(vexRT[Btn7R] == 1) {
			motor[PylonServo] = 127;
		}
	}
}
